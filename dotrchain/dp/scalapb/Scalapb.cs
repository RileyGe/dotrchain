// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: scalapb/scalapb.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Scalapb {

  /// <summary>Holder for reflection information generated from scalapb/scalapb.proto</summary>
  public static partial class ScalapbReflection {

    #region Descriptor
    /// <summary>File descriptor for scalapb/scalapb.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScalapbReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChVzY2FsYXBiL3NjYWxhcGIucHJvdG8SB3NjYWxhcGIaIGdvb2dsZS9wcm90",
            "b2J1Zi9kZXNjcmlwdG9yLnByb3RvIp4KCg5TY2FsYVBiT3B0aW9ucxIUCgxw",
            "YWNrYWdlX25hbWUYASABKAkSFAoMZmxhdF9wYWNrYWdlGAIgASgIEg4KBmlt",
            "cG9ydBgDIAMoCRIQCghwcmVhbWJsZRgEIAMoCRITCgtzaW5nbGVfZmlsZRgF",
            "IAEoCBIdChVub19wcmltaXRpdmVfd3JhcHBlcnMYByABKAgSGgoScHJpbWl0",
            "aXZlX3dyYXBwZXJzGAYgASgIEhcKD2NvbGxlY3Rpb25fdHlwZRgIIAEoCRIl",
            "ChdwcmVzZXJ2ZV91bmtub3duX2ZpZWxkcxgJIAEoCDoEdHJ1ZRITCgtvYmpl",
            "Y3RfbmFtZRgKIAEoCRIzCgVzY29wZRgLIAEoDjIkLnNjYWxhcGIuU2NhbGFQ",
            "Yk9wdGlvbnMuT3B0aW9uc1Njb3BlEhQKBmxlbnNlcxgMIAEoCDoEdHJ1ZRIf",
            "ChdyZXRhaW5fc291cmNlX2NvZGVfaW5mbxgNIAEoCBIQCghtYXBfdHlwZRgO",
            "IAEoCRIoCiBub19kZWZhdWx0X3ZhbHVlc19pbl9jb25zdHJ1Y3RvchgPIAEo",
            "CBJCChFlbnVtX3ZhbHVlX25hbWluZxgQIAEoDjInLnNjYWxhcGIuU2NhbGFQ",
            "Yk9wdGlvbnMuRW51bVZhbHVlTmFtaW5nEiAKEWVudW1fc3RyaXBfcHJlZml4",
            "GBEgASgIOgVmYWxzZRISCgpieXRlc190eXBlGBUgASgJEhgKEGphdmFfY29u",
            "dmVyc2lvbnMYFyABKAgSRgoTYXV4X21lc3NhZ2Vfb3B0aW9ucxgSIAMoCzIp",
            "LnNjYWxhcGIuU2NhbGFQYk9wdGlvbnMuQXV4TWVzc2FnZU9wdGlvbnMSQgoR",
            "YXV4X2ZpZWxkX29wdGlvbnMYEyADKAsyJy5zY2FsYXBiLlNjYWxhUGJPcHRp",
            "b25zLkF1eEZpZWxkT3B0aW9ucxJAChBhdXhfZW51bV9vcHRpb25zGBQgAygL",
            "MiYuc2NhbGFwYi5TY2FsYVBiT3B0aW9ucy5BdXhFbnVtT3B0aW9ucxJLChZh",
            "dXhfZW51bV92YWx1ZV9vcHRpb25zGBYgAygLMisuc2NhbGFwYi5TY2FsYVBi",
            "T3B0aW9ucy5BdXhFbnVtVmFsdWVPcHRpb25zEiYKHXRlc3Rfb25seV9ub19q",
            "YXZhX2NvbnZlcnNpb25zGOkHIAEoCBpNChFBdXhNZXNzYWdlT3B0aW9ucxIO",
            "CgZ0YXJnZXQYASABKAkSKAoHb3B0aW9ucxgCIAEoCzIXLnNjYWxhcGIuTWVz",
            "c2FnZU9wdGlvbnMaSQoPQXV4RmllbGRPcHRpb25zEg4KBnRhcmdldBgBIAEo",
            "CRImCgdvcHRpb25zGAIgASgLMhUuc2NhbGFwYi5GaWVsZE9wdGlvbnMaRwoO",
            "QXV4RW51bU9wdGlvbnMSDgoGdGFyZ2V0GAEgASgJEiUKB29wdGlvbnMYAiAB",
            "KAsyFC5zY2FsYXBiLkVudW1PcHRpb25zGlEKE0F1eEVudW1WYWx1ZU9wdGlv",
            "bnMSDgoGdGFyZ2V0GAEgASgJEioKB29wdGlvbnMYAiABKAsyGS5zY2FsYXBi",
            "LkVudW1WYWx1ZU9wdGlvbnMiJQoMT3B0aW9uc1Njb3BlEggKBEZJTEUQABIL",
            "CgdQQUNLQUdFEAEiMgoPRW51bVZhbHVlTmFtaW5nEg8KC0FTX0lOX1BST1RP",
            "EAASDgoKQ0FNRUxfQ0FTRRABKgkIkE4QgICAgAIi2wEKDk1lc3NhZ2VPcHRp",
            "b25zEg8KB2V4dGVuZHMYASADKAkSGQoRY29tcGFuaW9uX2V4dGVuZHMYAiAD",
            "KAkSEwoLYW5ub3RhdGlvbnMYAyADKAkSDAoEdHlwZRgEIAEoCRIdChVjb21w",
            "YW5pb25fYW5ub3RhdGlvbnMYBSADKAkSHAoUc2VhbGVkX29uZW9mX2V4dGVu",
            "ZHMYBiADKAkSDgoGbm9fYm94GAcgASgIEiIKGnVua25vd25fZmllbGRzX2Fu",
            "bm90YXRpb25zGAggAygJKgkIkE4QgICAgAIisQEKDEZpZWxkT3B0aW9ucxIM",
            "CgR0eXBlGAEgASgJEhIKCnNjYWxhX25hbWUYAiABKAkSFwoPY29sbGVjdGlv",
            "bl90eXBlGAMgASgJEhAKCGtleV90eXBlGAQgASgJEhIKCnZhbHVlX3R5cGUY",
            "BSABKAkSEwoLYW5ub3RhdGlvbnMYBiADKAkSEAoIbWFwX3R5cGUYByABKAkS",
            "DgoGbm9fYm94GB4gASgIKgkIkE4QgICAgAIiUgoLRW51bU9wdGlvbnMSDwoH",
            "ZXh0ZW5kcxgBIAMoCRIZChFjb21wYW5pb25fZXh0ZW5kcxgCIAMoCRIMCgR0",
            "eXBlGAMgASgJKgkIkE4QgICAgAIiQgoQRW51bVZhbHVlT3B0aW9ucxIPCgdl",
            "eHRlbmRzGAEgAygJEhIKCnNjYWxhX25hbWUYAiABKAkqCQiQThCAgICAAiI+",
            "CgxPbmVvZk9wdGlvbnMSDwoHZXh0ZW5kcxgBIAMoCRISCgpzY2FsYV9uYW1l",
            "GAIgASgJKgkIkE4QgICAgAI6RwoHb3B0aW9ucxIcLmdvb2dsZS5wcm90b2J1",
            "Zi5GaWxlT3B0aW9ucxj8ByABKAsyFy5zY2FsYXBiLlNjYWxhUGJPcHRpb25z",
            "OkoKB21lc3NhZ2USHy5nb29nbGUucHJvdG9idWYuTWVzc2FnZU9wdGlvbnMY",
            "/AcgASgLMhcuc2NhbGFwYi5NZXNzYWdlT3B0aW9uczpECgVmaWVsZBIdLmdv",
            "b2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnMY/AcgASgLMhUuc2NhbGFwYi5G",
            "aWVsZE9wdGlvbnM6SQoMZW51bV9vcHRpb25zEhwuZ29vZ2xlLnByb3RvYnVm",
            "LkVudW1PcHRpb25zGPwHIAEoCzIULnNjYWxhcGIuRW51bU9wdGlvbnM6UQoK",
            "ZW51bV92YWx1ZRIhLmdvb2dsZS5wcm90b2J1Zi5FbnVtVmFsdWVPcHRpb25z",
            "GPwHIAEoCzIZLnNjYWxhcGIuRW51bVZhbHVlT3B0aW9uczpECgVvbmVvZhId",
            "Lmdvb2dsZS5wcm90b2J1Zi5PbmVvZk9wdGlvbnMY/AcgASgLMhUuc2NhbGFw",
            "Yi5PbmVvZk9wdGlvbnNCJwoPc2NhbGFwYi5vcHRpb25z4j8TCg9zY2FsYXBi",
            "Lm9wdGlvbnMQAQ=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.Reflection.DescriptorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pb::Extension[] { ScalapbExtensions.Options, ScalapbExtensions.Message, ScalapbExtensions.Field, ScalapbExtensions.EnumOptions_, ScalapbExtensions.EnumValue, ScalapbExtensions.Oneof }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.ScalaPbOptions), global::Scalapb.ScalaPbOptions.Parser, new[]{ "PackageName", "FlatPackage", "Import", "Preamble", "SingleFile", "NoPrimitiveWrappers", "PrimitiveWrappers", "CollectionType", "PreserveUnknownFields", "ObjectName", "Scope", "Lenses", "RetainSourceCodeInfo", "MapType", "NoDefaultValuesInConstructor", "EnumValueNaming", "EnumStripPrefix", "BytesType", "JavaConversions", "AuxMessageOptions", "AuxFieldOptions", "AuxEnumOptions", "AuxEnumValueOptions", "TestOnlyNoJavaConversions" }, null, new[]{ typeof(global::Scalapb.ScalaPbOptions.Types.OptionsScope), typeof(global::Scalapb.ScalaPbOptions.Types.EnumValueNaming) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.ScalaPbOptions.Types.AuxMessageOptions), global::Scalapb.ScalaPbOptions.Types.AuxMessageOptions.Parser, new[]{ "Target", "Options" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.ScalaPbOptions.Types.AuxFieldOptions), global::Scalapb.ScalaPbOptions.Types.AuxFieldOptions.Parser, new[]{ "Target", "Options" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.ScalaPbOptions.Types.AuxEnumOptions), global::Scalapb.ScalaPbOptions.Types.AuxEnumOptions.Parser, new[]{ "Target", "Options" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.ScalaPbOptions.Types.AuxEnumValueOptions), global::Scalapb.ScalaPbOptions.Types.AuxEnumValueOptions.Parser, new[]{ "Target", "Options" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.MessageOptions), global::Scalapb.MessageOptions.Parser, new[]{ "Extends", "CompanionExtends", "Annotations", "Type", "CompanionAnnotations", "SealedOneofExtends", "NoBox", "UnknownFieldsAnnotations" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.FieldOptions), global::Scalapb.FieldOptions.Parser, new[]{ "Type", "ScalaName", "CollectionType", "KeyType", "ValueType", "Annotations", "MapType", "NoBox" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.EnumOptions), global::Scalapb.EnumOptions.Parser, new[]{ "Extends", "CompanionExtends", "Type" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.EnumValueOptions), global::Scalapb.EnumValueOptions.Parser, new[]{ "Extends", "ScalaName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Scalapb.OneofOptions), global::Scalapb.OneofOptions.Parser, new[]{ "Extends", "ScalaName" }, null, null, null, null)
          }));
    }
    #endregion

  }
  /// <summary>Holder for extension identifiers generated from the top level of scalapb/scalapb.proto</summary>
  public static partial class ScalapbExtensions {
    /// <summary>
    /// File-level optionals for ScalaPB.
    /// Extension number officially assigned by protobuf-global-extension-registry@google.com
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.FileOptions, global::Scalapb.ScalaPbOptions> Options =
      new pb::Extension<global::Google.Protobuf.Reflection.FileOptions, global::Scalapb.ScalaPbOptions>(1020, pb::FieldCodec.ForMessage(8162, global::Scalapb.ScalaPbOptions.Parser));
    /// <summary>
    /// Message-level optionals for ScalaPB.
    /// Extension number officially assigned by protobuf-global-extension-registry@google.com
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.MessageOptions, global::Scalapb.MessageOptions> Message =
      new pb::Extension<global::Google.Protobuf.Reflection.MessageOptions, global::Scalapb.MessageOptions>(1020, pb::FieldCodec.ForMessage(8162, global::Scalapb.MessageOptions.Parser));
    /// <summary>
    /// Field-level optionals for ScalaPB.
    /// Extension number officially assigned by protobuf-global-extension-registry@google.com
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::Scalapb.FieldOptions> Field =
      new pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::Scalapb.FieldOptions>(1020, pb::FieldCodec.ForMessage(8162, global::Scalapb.FieldOptions.Parser));
    /// <summary>
    /// Enum-level optionals for ScalaPB.
    /// Extension number officially assigned by protobuf-global-extension-registry@google.com
    ///
    /// The field is called enum_options and not enum since enum is not allowed in Java.
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.EnumOptions, global::Scalapb.EnumOptions> EnumOptions_ =
      new pb::Extension<global::Google.Protobuf.Reflection.EnumOptions, global::Scalapb.EnumOptions>(1020, pb::FieldCodec.ForMessage(8162, global::Scalapb.EnumOptions.Parser));
    /// <summary>
    /// Enum-level optionals for ScalaPB.
    /// Extension number officially assigned by protobuf-global-extension-registry@google.com
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.EnumValueOptions, global::Scalapb.EnumValueOptions> EnumValue =
      new pb::Extension<global::Google.Protobuf.Reflection.EnumValueOptions, global::Scalapb.EnumValueOptions>(1020, pb::FieldCodec.ForMessage(8162, global::Scalapb.EnumValueOptions.Parser));
    /// <summary>
    /// Enum-level optionals for ScalaPB.
    /// Extension number officially assigned by protobuf-global-extension-registry@google.com
    /// </summary>
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.OneofOptions, global::Scalapb.OneofOptions> Oneof =
      new pb::Extension<global::Google.Protobuf.Reflection.OneofOptions, global::Scalapb.OneofOptions>(1020, pb::FieldCodec.ForMessage(8162, global::Scalapb.OneofOptions.Parser));
  }

  #region Messages
  public sealed partial class ScalaPbOptions : pb::IExtendableMessage<ScalaPbOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScalaPbOptions> _parser = new pb::MessageParser<ScalaPbOptions>(() => new ScalaPbOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<ScalaPbOptions> _extensions;
    private pb::ExtensionSet<ScalaPbOptions> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScalaPbOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scalapb.ScalapbReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalaPbOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalaPbOptions(ScalaPbOptions other) : this() {
      _hasBits0 = other._hasBits0;
      packageName_ = other.packageName_;
      flatPackage_ = other.flatPackage_;
      import_ = other.import_.Clone();
      preamble_ = other.preamble_.Clone();
      singleFile_ = other.singleFile_;
      noPrimitiveWrappers_ = other.noPrimitiveWrappers_;
      primitiveWrappers_ = other.primitiveWrappers_;
      collectionType_ = other.collectionType_;
      preserveUnknownFields_ = other.preserveUnknownFields_;
      objectName_ = other.objectName_;
      scope_ = other.scope_;
      lenses_ = other.lenses_;
      retainSourceCodeInfo_ = other.retainSourceCodeInfo_;
      mapType_ = other.mapType_;
      noDefaultValuesInConstructor_ = other.noDefaultValuesInConstructor_;
      enumValueNaming_ = other.enumValueNaming_;
      enumStripPrefix_ = other.enumStripPrefix_;
      bytesType_ = other.bytesType_;
      javaConversions_ = other.javaConversions_;
      auxMessageOptions_ = other.auxMessageOptions_.Clone();
      auxFieldOptions_ = other.auxFieldOptions_.Clone();
      auxEnumOptions_ = other.auxEnumOptions_.Clone();
      auxEnumValueOptions_ = other.auxEnumValueOptions_.Clone();
      testOnlyNoJavaConversions_ = other.testOnlyNoJavaConversions_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScalaPbOptions Clone() {
      return new ScalaPbOptions(this);
    }

    /// <summary>Field number for the "package_name" field.</summary>
    public const int PackageNameFieldNumber = 1;
    private readonly static string PackageNameDefaultValue = "";

    private string packageName_;
    /// <summary>
    /// If set then it overrides the java_package and package.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PackageName {
      get { return packageName_ ?? PackageNameDefaultValue; }
      set {
        packageName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "package_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPackageName {
      get { return packageName_ != null; }
    }
    /// <summary>Clears the value of the "package_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPackageName() {
      packageName_ = null;
    }

    /// <summary>Field number for the "flat_package" field.</summary>
    public const int FlatPackageFieldNumber = 2;
    private readonly static bool FlatPackageDefaultValue = false;

    private bool flatPackage_;
    /// <summary>
    /// If true, the compiler does not append the proto base file name
    /// into the generated package name. If false (the default), the
    /// generated scala package name is the package_name.basename where
    /// basename is the proto file name without the .proto extension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FlatPackage {
      get { if ((_hasBits0 & 1) != 0) { return flatPackage_; } else { return FlatPackageDefaultValue; } }
      set {
        _hasBits0 |= 1;
        flatPackage_ = value;
      }
    }
    /// <summary>Gets whether the "flat_package" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFlatPackage {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "flat_package" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFlatPackage() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "import" field.</summary>
    public const int ImportFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_import_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> import_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Adds the following imports at the top of the file (this is meant
    /// to provide implicit TypeMappers)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Import {
      get { return import_; }
    }

    /// <summary>Field number for the "preamble" field.</summary>
    public const int PreambleFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_preamble_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> preamble_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Text to add to the generated scala file.  This can be used only
    /// when single_file is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Preamble {
      get { return preamble_; }
    }

    /// <summary>Field number for the "single_file" field.</summary>
    public const int SingleFileFieldNumber = 5;
    private readonly static bool SingleFileDefaultValue = false;

    private bool singleFile_;
    /// <summary>
    /// If true, all messages and enums (but not services) will be written
    /// to a single Scala file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SingleFile {
      get { if ((_hasBits0 & 2) != 0) { return singleFile_; } else { return SingleFileDefaultValue; } }
      set {
        _hasBits0 |= 2;
        singleFile_ = value;
      }
    }
    /// <summary>Gets whether the "single_file" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSingleFile {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "single_file" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSingleFile() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "no_primitive_wrappers" field.</summary>
    public const int NoPrimitiveWrappersFieldNumber = 7;
    private readonly static bool NoPrimitiveWrappersDefaultValue = false;

    private bool noPrimitiveWrappers_;
    /// <summary>
    /// By default, wrappers defined at
    /// https://github.com/google/protobuf/blob/master/src/google/protobuf/wrappers.proto,
    /// are mapped to an Option[T] where T is a primitive type. When this field
    /// is set to true, we do not perform this transformation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NoPrimitiveWrappers {
      get { if ((_hasBits0 & 8) != 0) { return noPrimitiveWrappers_; } else { return NoPrimitiveWrappersDefaultValue; } }
      set {
        _hasBits0 |= 8;
        noPrimitiveWrappers_ = value;
      }
    }
    /// <summary>Gets whether the "no_primitive_wrappers" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNoPrimitiveWrappers {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "no_primitive_wrappers" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNoPrimitiveWrappers() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "primitive_wrappers" field.</summary>
    public const int PrimitiveWrappersFieldNumber = 6;
    private readonly static bool PrimitiveWrappersDefaultValue = false;

    private bool primitiveWrappers_;
    /// <summary>
    /// DEPRECATED. In ScalaPB &lt;= 0.5.47, it was necessary to explicitly enable
    /// primitive_wrappers. This field remains here for backwards compatibility,
    /// but it has no effect on generated code. It is an error to set both
    /// `primitive_wrappers` and `no_primitive_wrappers`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PrimitiveWrappers {
      get { if ((_hasBits0 & 4) != 0) { return primitiveWrappers_; } else { return PrimitiveWrappersDefaultValue; } }
      set {
        _hasBits0 |= 4;
        primitiveWrappers_ = value;
      }
    }
    /// <summary>Gets whether the "primitive_wrappers" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPrimitiveWrappers {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "primitive_wrappers" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPrimitiveWrappers() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "collection_type" field.</summary>
    public const int CollectionTypeFieldNumber = 8;
    private readonly static string CollectionTypeDefaultValue = "";

    private string collectionType_;
    /// <summary>
    /// Scala type to be used for repeated fields. If unspecified,
    /// `scala.collection.Seq` will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectionType {
      get { return collectionType_ ?? CollectionTypeDefaultValue; }
      set {
        collectionType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "collection_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCollectionType {
      get { return collectionType_ != null; }
    }
    /// <summary>Clears the value of the "collection_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCollectionType() {
      collectionType_ = null;
    }

    /// <summary>Field number for the "preserve_unknown_fields" field.</summary>
    public const int PreserveUnknownFieldsFieldNumber = 9;
    private readonly static bool PreserveUnknownFieldsDefaultValue = true;

    private bool preserveUnknownFields_;
    /// <summary>
    /// If set to true, all generated messages in this file will preserve unknown
    /// fields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PreserveUnknownFields {
      get { if ((_hasBits0 & 16) != 0) { return preserveUnknownFields_; } else { return PreserveUnknownFieldsDefaultValue; } }
      set {
        _hasBits0 |= 16;
        preserveUnknownFields_ = value;
      }
    }
    /// <summary>Gets whether the "preserve_unknown_fields" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPreserveUnknownFields {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "preserve_unknown_fields" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPreserveUnknownFields() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "object_name" field.</summary>
    public const int ObjectNameFieldNumber = 10;
    private readonly static string ObjectNameDefaultValue = "";

    private string objectName_;
    /// <summary>
    /// If defined, sets the name of the file-level object that would be generated. This
    /// object extends `GeneratedFileObject` and contains descriptors, and list of message
    /// and enum companions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ObjectName {
      get { return objectName_ ?? ObjectNameDefaultValue; }
      set {
        objectName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "object_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasObjectName {
      get { return objectName_ != null; }
    }
    /// <summary>Clears the value of the "object_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearObjectName() {
      objectName_ = null;
    }

    /// <summary>Field number for the "scope" field.</summary>
    public const int ScopeFieldNumber = 11;
    private readonly static global::Scalapb.ScalaPbOptions.Types.OptionsScope ScopeDefaultValue = global::Scalapb.ScalaPbOptions.Types.OptionsScope.File;

    private global::Scalapb.ScalaPbOptions.Types.OptionsScope scope_;
    /// <summary>
    /// Experimental: scope to apply the given options.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Scalapb.ScalaPbOptions.Types.OptionsScope Scope {
      get { if ((_hasBits0 & 32) != 0) { return scope_; } else { return ScopeDefaultValue; } }
      set {
        _hasBits0 |= 32;
        scope_ = value;
      }
    }
    /// <summary>Gets whether the "scope" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScope {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "scope" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScope() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "lenses" field.</summary>
    public const int LensesFieldNumber = 12;
    private readonly static bool LensesDefaultValue = true;

    private bool lenses_;
    /// <summary>
    /// If true, lenses will be generated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Lenses {
      get { if ((_hasBits0 & 64) != 0) { return lenses_; } else { return LensesDefaultValue; } }
      set {
        _hasBits0 |= 64;
        lenses_ = value;
      }
    }
    /// <summary>Gets whether the "lenses" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLenses {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "lenses" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLenses() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "retain_source_code_info" field.</summary>
    public const int RetainSourceCodeInfoFieldNumber = 13;
    private readonly static bool RetainSourceCodeInfoDefaultValue = false;

    private bool retainSourceCodeInfo_;
    /// <summary>
    /// If true, then source-code info information will be included in the
    /// generated code - normally the source code info is cleared out to reduce
    /// code size.  The source code info is useful for extracting source code
    /// location from the descriptors as well as comments.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RetainSourceCodeInfo {
      get { if ((_hasBits0 & 128) != 0) { return retainSourceCodeInfo_; } else { return RetainSourceCodeInfoDefaultValue; } }
      set {
        _hasBits0 |= 128;
        retainSourceCodeInfo_ = value;
      }
    }
    /// <summary>Gets whether the "retain_source_code_info" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRetainSourceCodeInfo {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "retain_source_code_info" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRetainSourceCodeInfo() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "map_type" field.</summary>
    public const int MapTypeFieldNumber = 14;
    private readonly static string MapTypeDefaultValue = "";

    private string mapType_;
    /// <summary>
    /// Scala type to be used for maps. If unspecified,
    /// `scala.collection.immutable.Map` will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MapType {
      get { return mapType_ ?? MapTypeDefaultValue; }
      set {
        mapType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "map_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMapType {
      get { return mapType_ != null; }
    }
    /// <summary>Clears the value of the "map_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMapType() {
      mapType_ = null;
    }

    /// <summary>Field number for the "no_default_values_in_constructor" field.</summary>
    public const int NoDefaultValuesInConstructorFieldNumber = 15;
    private readonly static bool NoDefaultValuesInConstructorDefaultValue = false;

    private bool noDefaultValuesInConstructor_;
    /// <summary>
    /// If true, no default values will be generated in message constructors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NoDefaultValuesInConstructor {
      get { if ((_hasBits0 & 256) != 0) { return noDefaultValuesInConstructor_; } else { return NoDefaultValuesInConstructorDefaultValue; } }
      set {
        _hasBits0 |= 256;
        noDefaultValuesInConstructor_ = value;
      }
    }
    /// <summary>Gets whether the "no_default_values_in_constructor" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNoDefaultValuesInConstructor {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "no_default_values_in_constructor" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNoDefaultValuesInConstructor() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "enum_value_naming" field.</summary>
    public const int EnumValueNamingFieldNumber = 16;
    private readonly static global::Scalapb.ScalaPbOptions.Types.EnumValueNaming EnumValueNamingDefaultValue = global::Scalapb.ScalaPbOptions.Types.EnumValueNaming.AsInProto;

    private global::Scalapb.ScalaPbOptions.Types.EnumValueNaming enumValueNaming_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Scalapb.ScalaPbOptions.Types.EnumValueNaming EnumValueNaming {
      get { if ((_hasBits0 & 512) != 0) { return enumValueNaming_; } else { return EnumValueNamingDefaultValue; } }
      set {
        _hasBits0 |= 512;
        enumValueNaming_ = value;
      }
    }
    /// <summary>Gets whether the "enum_value_naming" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEnumValueNaming {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "enum_value_naming" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEnumValueNaming() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "enum_strip_prefix" field.</summary>
    public const int EnumStripPrefixFieldNumber = 17;
    private readonly static bool EnumStripPrefixDefaultValue = false;

    private bool enumStripPrefix_;
    /// <summary>
    /// Indicate if prefix (enum name + optional underscore) should be removed in scala code
    /// Strip is applied before enum value naming changes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EnumStripPrefix {
      get { if ((_hasBits0 & 1024) != 0) { return enumStripPrefix_; } else { return EnumStripPrefixDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        enumStripPrefix_ = value;
      }
    }
    /// <summary>Gets whether the "enum_strip_prefix" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEnumStripPrefix {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "enum_strip_prefix" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEnumStripPrefix() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "bytes_type" field.</summary>
    public const int BytesTypeFieldNumber = 21;
    private readonly static string BytesTypeDefaultValue = "";

    private string bytesType_;
    /// <summary>
    /// Scala type to use for bytes fields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BytesType {
      get { return bytesType_ ?? BytesTypeDefaultValue; }
      set {
        bytesType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "bytes_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBytesType {
      get { return bytesType_ != null; }
    }
    /// <summary>Clears the value of the "bytes_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBytesType() {
      bytesType_ = null;
    }

    /// <summary>Field number for the "java_conversions" field.</summary>
    public const int JavaConversionsFieldNumber = 23;
    private readonly static bool JavaConversionsDefaultValue = false;

    private bool javaConversions_;
    /// <summary>
    /// Enable java conversions for this file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool JavaConversions {
      get { if ((_hasBits0 & 2048) != 0) { return javaConversions_; } else { return JavaConversionsDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        javaConversions_ = value;
      }
    }
    /// <summary>Gets whether the "java_conversions" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasJavaConversions {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "java_conversions" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearJavaConversions() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "aux_message_options" field.</summary>
    public const int AuxMessageOptionsFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Scalapb.ScalaPbOptions.Types.AuxMessageOptions> _repeated_auxMessageOptions_codec
        = pb::FieldCodec.ForMessage(146, global::Scalapb.ScalaPbOptions.Types.AuxMessageOptions.Parser);
    private readonly pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxMessageOptions> auxMessageOptions_ = new pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxMessageOptions>();
    /// <summary>
    /// List of message options to apply to some messages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxMessageOptions> AuxMessageOptions {
      get { return auxMessageOptions_; }
    }

    /// <summary>Field number for the "aux_field_options" field.</summary>
    public const int AuxFieldOptionsFieldNumber = 19;
    private static readonly pb::FieldCodec<global::Scalapb.ScalaPbOptions.Types.AuxFieldOptions> _repeated_auxFieldOptions_codec
        = pb::FieldCodec.ForMessage(154, global::Scalapb.ScalaPbOptions.Types.AuxFieldOptions.Parser);
    private readonly pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxFieldOptions> auxFieldOptions_ = new pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxFieldOptions>();
    /// <summary>
    /// List of message options to apply to some fields.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxFieldOptions> AuxFieldOptions {
      get { return auxFieldOptions_; }
    }

    /// <summary>Field number for the "aux_enum_options" field.</summary>
    public const int AuxEnumOptionsFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Scalapb.ScalaPbOptions.Types.AuxEnumOptions> _repeated_auxEnumOptions_codec
        = pb::FieldCodec.ForMessage(162, global::Scalapb.ScalaPbOptions.Types.AuxEnumOptions.Parser);
    private readonly pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxEnumOptions> auxEnumOptions_ = new pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxEnumOptions>();
    /// <summary>
    /// List of message options to apply to some enums.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxEnumOptions> AuxEnumOptions {
      get { return auxEnumOptions_; }
    }

    /// <summary>Field number for the "aux_enum_value_options" field.</summary>
    public const int AuxEnumValueOptionsFieldNumber = 22;
    private static readonly pb::FieldCodec<global::Scalapb.ScalaPbOptions.Types.AuxEnumValueOptions> _repeated_auxEnumValueOptions_codec
        = pb::FieldCodec.ForMessage(178, global::Scalapb.ScalaPbOptions.Types.AuxEnumValueOptions.Parser);
    private readonly pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxEnumValueOptions> auxEnumValueOptions_ = new pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxEnumValueOptions>();
    /// <summary>
    /// List of enum value options to apply to some enum values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Scalapb.ScalaPbOptions.Types.AuxEnumValueOptions> AuxEnumValueOptions {
      get { return auxEnumValueOptions_; }
    }

    /// <summary>Field number for the "test_only_no_java_conversions" field.</summary>
    public const int TestOnlyNoJavaConversionsFieldNumber = 1001;
    private readonly static bool TestOnlyNoJavaConversionsDefaultValue = false;

    private bool testOnlyNoJavaConversions_;
    /// <summary>
    /// For use in tests only. Inhibit Java conversions even when when generator parameters
    /// request for it.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool TestOnlyNoJavaConversions {
      get { if ((_hasBits0 & 4096) != 0) { return testOnlyNoJavaConversions_; } else { return TestOnlyNoJavaConversionsDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        testOnlyNoJavaConversions_ = value;
      }
    }
    /// <summary>Gets whether the "test_only_no_java_conversions" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTestOnlyNoJavaConversions {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "test_only_no_java_conversions" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTestOnlyNoJavaConversions() {
      _hasBits0 &= ~4096;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScalaPbOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScalaPbOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PackageName != other.PackageName) return false;
      if (FlatPackage != other.FlatPackage) return false;
      if(!import_.Equals(other.import_)) return false;
      if(!preamble_.Equals(other.preamble_)) return false;
      if (SingleFile != other.SingleFile) return false;
      if (NoPrimitiveWrappers != other.NoPrimitiveWrappers) return false;
      if (PrimitiveWrappers != other.PrimitiveWrappers) return false;
      if (CollectionType != other.CollectionType) return false;
      if (PreserveUnknownFields != other.PreserveUnknownFields) return false;
      if (ObjectName != other.ObjectName) return false;
      if (Scope != other.Scope) return false;
      if (Lenses != other.Lenses) return false;
      if (RetainSourceCodeInfo != other.RetainSourceCodeInfo) return false;
      if (MapType != other.MapType) return false;
      if (NoDefaultValuesInConstructor != other.NoDefaultValuesInConstructor) return false;
      if (EnumValueNaming != other.EnumValueNaming) return false;
      if (EnumStripPrefix != other.EnumStripPrefix) return false;
      if (BytesType != other.BytesType) return false;
      if (JavaConversions != other.JavaConversions) return false;
      if(!auxMessageOptions_.Equals(other.auxMessageOptions_)) return false;
      if(!auxFieldOptions_.Equals(other.auxFieldOptions_)) return false;
      if(!auxEnumOptions_.Equals(other.auxEnumOptions_)) return false;
      if(!auxEnumValueOptions_.Equals(other.auxEnumValueOptions_)) return false;
      if (TestOnlyNoJavaConversions != other.TestOnlyNoJavaConversions) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPackageName) hash ^= PackageName.GetHashCode();
      if (HasFlatPackage) hash ^= FlatPackage.GetHashCode();
      hash ^= import_.GetHashCode();
      hash ^= preamble_.GetHashCode();
      if (HasSingleFile) hash ^= SingleFile.GetHashCode();
      if (HasNoPrimitiveWrappers) hash ^= NoPrimitiveWrappers.GetHashCode();
      if (HasPrimitiveWrappers) hash ^= PrimitiveWrappers.GetHashCode();
      if (HasCollectionType) hash ^= CollectionType.GetHashCode();
      if (HasPreserveUnknownFields) hash ^= PreserveUnknownFields.GetHashCode();
      if (HasObjectName) hash ^= ObjectName.GetHashCode();
      if (HasScope) hash ^= Scope.GetHashCode();
      if (HasLenses) hash ^= Lenses.GetHashCode();
      if (HasRetainSourceCodeInfo) hash ^= RetainSourceCodeInfo.GetHashCode();
      if (HasMapType) hash ^= MapType.GetHashCode();
      if (HasNoDefaultValuesInConstructor) hash ^= NoDefaultValuesInConstructor.GetHashCode();
      if (HasEnumValueNaming) hash ^= EnumValueNaming.GetHashCode();
      if (HasEnumStripPrefix) hash ^= EnumStripPrefix.GetHashCode();
      if (HasBytesType) hash ^= BytesType.GetHashCode();
      if (HasJavaConversions) hash ^= JavaConversions.GetHashCode();
      hash ^= auxMessageOptions_.GetHashCode();
      hash ^= auxFieldOptions_.GetHashCode();
      hash ^= auxEnumOptions_.GetHashCode();
      hash ^= auxEnumValueOptions_.GetHashCode();
      if (HasTestOnlyNoJavaConversions) hash ^= TestOnlyNoJavaConversions.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPackageName) {
        output.WriteRawTag(10);
        output.WriteString(PackageName);
      }
      if (HasFlatPackage) {
        output.WriteRawTag(16);
        output.WriteBool(FlatPackage);
      }
      import_.WriteTo(output, _repeated_import_codec);
      preamble_.WriteTo(output, _repeated_preamble_codec);
      if (HasSingleFile) {
        output.WriteRawTag(40);
        output.WriteBool(SingleFile);
      }
      if (HasPrimitiveWrappers) {
        output.WriteRawTag(48);
        output.WriteBool(PrimitiveWrappers);
      }
      if (HasNoPrimitiveWrappers) {
        output.WriteRawTag(56);
        output.WriteBool(NoPrimitiveWrappers);
      }
      if (HasCollectionType) {
        output.WriteRawTag(66);
        output.WriteString(CollectionType);
      }
      if (HasPreserveUnknownFields) {
        output.WriteRawTag(72);
        output.WriteBool(PreserveUnknownFields);
      }
      if (HasObjectName) {
        output.WriteRawTag(82);
        output.WriteString(ObjectName);
      }
      if (HasScope) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Scope);
      }
      if (HasLenses) {
        output.WriteRawTag(96);
        output.WriteBool(Lenses);
      }
      if (HasRetainSourceCodeInfo) {
        output.WriteRawTag(104);
        output.WriteBool(RetainSourceCodeInfo);
      }
      if (HasMapType) {
        output.WriteRawTag(114);
        output.WriteString(MapType);
      }
      if (HasNoDefaultValuesInConstructor) {
        output.WriteRawTag(120);
        output.WriteBool(NoDefaultValuesInConstructor);
      }
      if (HasEnumValueNaming) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) EnumValueNaming);
      }
      if (HasEnumStripPrefix) {
        output.WriteRawTag(136, 1);
        output.WriteBool(EnumStripPrefix);
      }
      auxMessageOptions_.WriteTo(output, _repeated_auxMessageOptions_codec);
      auxFieldOptions_.WriteTo(output, _repeated_auxFieldOptions_codec);
      auxEnumOptions_.WriteTo(output, _repeated_auxEnumOptions_codec);
      if (HasBytesType) {
        output.WriteRawTag(170, 1);
        output.WriteString(BytesType);
      }
      auxEnumValueOptions_.WriteTo(output, _repeated_auxEnumValueOptions_codec);
      if (HasJavaConversions) {
        output.WriteRawTag(184, 1);
        output.WriteBool(JavaConversions);
      }
      if (HasTestOnlyNoJavaConversions) {
        output.WriteRawTag(200, 62);
        output.WriteBool(TestOnlyNoJavaConversions);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPackageName) {
        output.WriteRawTag(10);
        output.WriteString(PackageName);
      }
      if (HasFlatPackage) {
        output.WriteRawTag(16);
        output.WriteBool(FlatPackage);
      }
      import_.WriteTo(ref output, _repeated_import_codec);
      preamble_.WriteTo(ref output, _repeated_preamble_codec);
      if (HasSingleFile) {
        output.WriteRawTag(40);
        output.WriteBool(SingleFile);
      }
      if (HasPrimitiveWrappers) {
        output.WriteRawTag(48);
        output.WriteBool(PrimitiveWrappers);
      }
      if (HasNoPrimitiveWrappers) {
        output.WriteRawTag(56);
        output.WriteBool(NoPrimitiveWrappers);
      }
      if (HasCollectionType) {
        output.WriteRawTag(66);
        output.WriteString(CollectionType);
      }
      if (HasPreserveUnknownFields) {
        output.WriteRawTag(72);
        output.WriteBool(PreserveUnknownFields);
      }
      if (HasObjectName) {
        output.WriteRawTag(82);
        output.WriteString(ObjectName);
      }
      if (HasScope) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Scope);
      }
      if (HasLenses) {
        output.WriteRawTag(96);
        output.WriteBool(Lenses);
      }
      if (HasRetainSourceCodeInfo) {
        output.WriteRawTag(104);
        output.WriteBool(RetainSourceCodeInfo);
      }
      if (HasMapType) {
        output.WriteRawTag(114);
        output.WriteString(MapType);
      }
      if (HasNoDefaultValuesInConstructor) {
        output.WriteRawTag(120);
        output.WriteBool(NoDefaultValuesInConstructor);
      }
      if (HasEnumValueNaming) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) EnumValueNaming);
      }
      if (HasEnumStripPrefix) {
        output.WriteRawTag(136, 1);
        output.WriteBool(EnumStripPrefix);
      }
      auxMessageOptions_.WriteTo(ref output, _repeated_auxMessageOptions_codec);
      auxFieldOptions_.WriteTo(ref output, _repeated_auxFieldOptions_codec);
      auxEnumOptions_.WriteTo(ref output, _repeated_auxEnumOptions_codec);
      if (HasBytesType) {
        output.WriteRawTag(170, 1);
        output.WriteString(BytesType);
      }
      auxEnumValueOptions_.WriteTo(ref output, _repeated_auxEnumValueOptions_codec);
      if (HasJavaConversions) {
        output.WriteRawTag(184, 1);
        output.WriteBool(JavaConversions);
      }
      if (HasTestOnlyNoJavaConversions) {
        output.WriteRawTag(200, 62);
        output.WriteBool(TestOnlyNoJavaConversions);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasPackageName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PackageName);
      }
      if (HasFlatPackage) {
        size += 1 + 1;
      }
      size += import_.CalculateSize(_repeated_import_codec);
      size += preamble_.CalculateSize(_repeated_preamble_codec);
      if (HasSingleFile) {
        size += 1 + 1;
      }
      if (HasNoPrimitiveWrappers) {
        size += 1 + 1;
      }
      if (HasPrimitiveWrappers) {
        size += 1 + 1;
      }
      if (HasCollectionType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectionType);
      }
      if (HasPreserveUnknownFields) {
        size += 1 + 1;
      }
      if (HasObjectName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ObjectName);
      }
      if (HasScope) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Scope);
      }
      if (HasLenses) {
        size += 1 + 1;
      }
      if (HasRetainSourceCodeInfo) {
        size += 1 + 1;
      }
      if (HasMapType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MapType);
      }
      if (HasNoDefaultValuesInConstructor) {
        size += 1 + 1;
      }
      if (HasEnumValueNaming) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) EnumValueNaming);
      }
      if (HasEnumStripPrefix) {
        size += 2 + 1;
      }
      if (HasBytesType) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(BytesType);
      }
      if (HasJavaConversions) {
        size += 2 + 1;
      }
      size += auxMessageOptions_.CalculateSize(_repeated_auxMessageOptions_codec);
      size += auxFieldOptions_.CalculateSize(_repeated_auxFieldOptions_codec);
      size += auxEnumOptions_.CalculateSize(_repeated_auxEnumOptions_codec);
      size += auxEnumValueOptions_.CalculateSize(_repeated_auxEnumValueOptions_codec);
      if (HasTestOnlyNoJavaConversions) {
        size += 2 + 1;
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScalaPbOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasPackageName) {
        PackageName = other.PackageName;
      }
      if (other.HasFlatPackage) {
        FlatPackage = other.FlatPackage;
      }
      import_.Add(other.import_);
      preamble_.Add(other.preamble_);
      if (other.HasSingleFile) {
        SingleFile = other.SingleFile;
      }
      if (other.HasNoPrimitiveWrappers) {
        NoPrimitiveWrappers = other.NoPrimitiveWrappers;
      }
      if (other.HasPrimitiveWrappers) {
        PrimitiveWrappers = other.PrimitiveWrappers;
      }
      if (other.HasCollectionType) {
        CollectionType = other.CollectionType;
      }
      if (other.HasPreserveUnknownFields) {
        PreserveUnknownFields = other.PreserveUnknownFields;
      }
      if (other.HasObjectName) {
        ObjectName = other.ObjectName;
      }
      if (other.HasScope) {
        Scope = other.Scope;
      }
      if (other.HasLenses) {
        Lenses = other.Lenses;
      }
      if (other.HasRetainSourceCodeInfo) {
        RetainSourceCodeInfo = other.RetainSourceCodeInfo;
      }
      if (other.HasMapType) {
        MapType = other.MapType;
      }
      if (other.HasNoDefaultValuesInConstructor) {
        NoDefaultValuesInConstructor = other.NoDefaultValuesInConstructor;
      }
      if (other.HasEnumValueNaming) {
        EnumValueNaming = other.EnumValueNaming;
      }
      if (other.HasEnumStripPrefix) {
        EnumStripPrefix = other.EnumStripPrefix;
      }
      if (other.HasBytesType) {
        BytesType = other.BytesType;
      }
      if (other.HasJavaConversions) {
        JavaConversions = other.JavaConversions;
      }
      auxMessageOptions_.Add(other.auxMessageOptions_);
      auxFieldOptions_.Add(other.auxFieldOptions_);
      auxEnumOptions_.Add(other.auxEnumOptions_);
      auxEnumValueOptions_.Add(other.auxEnumValueOptions_);
      if (other.HasTestOnlyNoJavaConversions) {
        TestOnlyNoJavaConversions = other.TestOnlyNoJavaConversions;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            PackageName = input.ReadString();
            break;
          }
          case 16: {
            FlatPackage = input.ReadBool();
            break;
          }
          case 26: {
            import_.AddEntriesFrom(input, _repeated_import_codec);
            break;
          }
          case 34: {
            preamble_.AddEntriesFrom(input, _repeated_preamble_codec);
            break;
          }
          case 40: {
            SingleFile = input.ReadBool();
            break;
          }
          case 48: {
            PrimitiveWrappers = input.ReadBool();
            break;
          }
          case 56: {
            NoPrimitiveWrappers = input.ReadBool();
            break;
          }
          case 66: {
            CollectionType = input.ReadString();
            break;
          }
          case 72: {
            PreserveUnknownFields = input.ReadBool();
            break;
          }
          case 82: {
            ObjectName = input.ReadString();
            break;
          }
          case 88: {
            Scope = (global::Scalapb.ScalaPbOptions.Types.OptionsScope) input.ReadEnum();
            break;
          }
          case 96: {
            Lenses = input.ReadBool();
            break;
          }
          case 104: {
            RetainSourceCodeInfo = input.ReadBool();
            break;
          }
          case 114: {
            MapType = input.ReadString();
            break;
          }
          case 120: {
            NoDefaultValuesInConstructor = input.ReadBool();
            break;
          }
          case 128: {
            EnumValueNaming = (global::Scalapb.ScalaPbOptions.Types.EnumValueNaming) input.ReadEnum();
            break;
          }
          case 136: {
            EnumStripPrefix = input.ReadBool();
            break;
          }
          case 146: {
            auxMessageOptions_.AddEntriesFrom(input, _repeated_auxMessageOptions_codec);
            break;
          }
          case 154: {
            auxFieldOptions_.AddEntriesFrom(input, _repeated_auxFieldOptions_codec);
            break;
          }
          case 162: {
            auxEnumOptions_.AddEntriesFrom(input, _repeated_auxEnumOptions_codec);
            break;
          }
          case 170: {
            BytesType = input.ReadString();
            break;
          }
          case 178: {
            auxEnumValueOptions_.AddEntriesFrom(input, _repeated_auxEnumValueOptions_codec);
            break;
          }
          case 184: {
            JavaConversions = input.ReadBool();
            break;
          }
          case 8008: {
            TestOnlyNoJavaConversions = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            PackageName = input.ReadString();
            break;
          }
          case 16: {
            FlatPackage = input.ReadBool();
            break;
          }
          case 26: {
            import_.AddEntriesFrom(ref input, _repeated_import_codec);
            break;
          }
          case 34: {
            preamble_.AddEntriesFrom(ref input, _repeated_preamble_codec);
            break;
          }
          case 40: {
            SingleFile = input.ReadBool();
            break;
          }
          case 48: {
            PrimitiveWrappers = input.ReadBool();
            break;
          }
          case 56: {
            NoPrimitiveWrappers = input.ReadBool();
            break;
          }
          case 66: {
            CollectionType = input.ReadString();
            break;
          }
          case 72: {
            PreserveUnknownFields = input.ReadBool();
            break;
          }
          case 82: {
            ObjectName = input.ReadString();
            break;
          }
          case 88: {
            Scope = (global::Scalapb.ScalaPbOptions.Types.OptionsScope) input.ReadEnum();
            break;
          }
          case 96: {
            Lenses = input.ReadBool();
            break;
          }
          case 104: {
            RetainSourceCodeInfo = input.ReadBool();
            break;
          }
          case 114: {
            MapType = input.ReadString();
            break;
          }
          case 120: {
            NoDefaultValuesInConstructor = input.ReadBool();
            break;
          }
          case 128: {
            EnumValueNaming = (global::Scalapb.ScalaPbOptions.Types.EnumValueNaming) input.ReadEnum();
            break;
          }
          case 136: {
            EnumStripPrefix = input.ReadBool();
            break;
          }
          case 146: {
            auxMessageOptions_.AddEntriesFrom(ref input, _repeated_auxMessageOptions_codec);
            break;
          }
          case 154: {
            auxFieldOptions_.AddEntriesFrom(ref input, _repeated_auxFieldOptions_codec);
            break;
          }
          case 162: {
            auxEnumOptions_.AddEntriesFrom(ref input, _repeated_auxEnumOptions_codec);
            break;
          }
          case 170: {
            BytesType = input.ReadString();
            break;
          }
          case 178: {
            auxEnumValueOptions_.AddEntriesFrom(ref input, _repeated_auxEnumValueOptions_codec);
            break;
          }
          case 184: {
            JavaConversions = input.ReadBool();
            break;
          }
          case 8008: {
            TestOnlyNoJavaConversions = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<ScalaPbOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<ScalaPbOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<ScalaPbOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<ScalaPbOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<ScalaPbOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<ScalaPbOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<ScalaPbOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ScalaPbOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Whether to apply the options only to this file, or for the entire package (and its subpackages)
      /// </summary>
      public enum OptionsScope {
        /// <summary>
        /// Apply the options for this file only (default)
        /// </summary>
        [pbr::OriginalName("FILE")] File = 0,
        /// <summary>
        /// Apply the options for the entire package and its subpackages.
        /// </summary>
        [pbr::OriginalName("PACKAGE")] Package = 1,
      }

      /// <summary>
      /// Naming convention for generated enum values 
      /// </summary>
      public enum EnumValueNaming {
        /// <summary>
        /// Enum value names in Scala use the same name as in the proto
        /// </summary>
        [pbr::OriginalName("AS_IN_PROTO")] AsInProto = 0,
        /// <summary>
        /// Convert enum values to CamelCase in Scala.
        /// </summary>
        [pbr::OriginalName("CAMEL_CASE")] CamelCase = 1,
      }

      /// <summary>
      /// AuxMessageOptions enables you to set message-level options through package-scoped options.
      /// This is useful when you can't add a dependency on scalapb.proto from the proto file that
      /// defines the message.
      /// </summary>
      public sealed partial class AuxMessageOptions : pb::IMessage<AuxMessageOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AuxMessageOptions> _parser = new pb::MessageParser<AuxMessageOptions>(() => new AuxMessageOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AuxMessageOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Scalapb.ScalaPbOptions.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxMessageOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxMessageOptions(AuxMessageOptions other) : this() {
          target_ = other.target_;
          options_ = other.options_ != null ? other.options_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxMessageOptions Clone() {
          return new AuxMessageOptions(this);
        }

        /// <summary>Field number for the "target" field.</summary>
        public const int TargetFieldNumber = 1;
        private readonly static string TargetDefaultValue = "";

        private string target_;
        /// <summary>
        /// The fully-qualified name of the message in the proto name space.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Target {
          get { return target_ ?? TargetDefaultValue; }
          set {
            target_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "target" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTarget {
          get { return target_ != null; }
        }
        /// <summary>Clears the value of the "target" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTarget() {
          target_ = null;
        }

        /// <summary>Field number for the "options" field.</summary>
        public const int OptionsFieldNumber = 2;
        private global::Scalapb.MessageOptions options_;
        /// <summary>
        /// Options to apply to the message. If there are any options defined on the target message
        /// they take precedence over the options.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Scalapb.MessageOptions Options {
          get { return options_; }
          set {
            options_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AuxMessageOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AuxMessageOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Target != other.Target) return false;
          if (!object.Equals(Options, other.Options)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasTarget) hash ^= Target.GetHashCode();
          if (options_ != null) hash ^= Options.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasTarget) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Target);
          }
          if (options_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Options);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AuxMessageOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasTarget) {
            Target = other.Target;
          }
          if (other.options_ != null) {
            if (options_ == null) {
              Options = new global::Scalapb.MessageOptions();
            }
            Options.MergeFrom(other.Options);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.MessageOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.MessageOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// AuxFieldOptions enables you to set field-level options through package-scoped options.
      /// This is useful when you can't add a dependency on scalapb.proto from the proto file that
      /// defines the field.
      /// </summary>
      public sealed partial class AuxFieldOptions : pb::IMessage<AuxFieldOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AuxFieldOptions> _parser = new pb::MessageParser<AuxFieldOptions>(() => new AuxFieldOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AuxFieldOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Scalapb.ScalaPbOptions.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxFieldOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxFieldOptions(AuxFieldOptions other) : this() {
          target_ = other.target_;
          options_ = other.options_ != null ? other.options_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxFieldOptions Clone() {
          return new AuxFieldOptions(this);
        }

        /// <summary>Field number for the "target" field.</summary>
        public const int TargetFieldNumber = 1;
        private readonly static string TargetDefaultValue = "";

        private string target_;
        /// <summary>
        /// The fully-qualified name of the field in the proto name space.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Target {
          get { return target_ ?? TargetDefaultValue; }
          set {
            target_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "target" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTarget {
          get { return target_ != null; }
        }
        /// <summary>Clears the value of the "target" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTarget() {
          target_ = null;
        }

        /// <summary>Field number for the "options" field.</summary>
        public const int OptionsFieldNumber = 2;
        private global::Scalapb.FieldOptions options_;
        /// <summary>
        /// Options to apply to the field. If there are any options defined on the target message
        /// they take precedence over the options.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Scalapb.FieldOptions Options {
          get { return options_; }
          set {
            options_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AuxFieldOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AuxFieldOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Target != other.Target) return false;
          if (!object.Equals(Options, other.Options)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasTarget) hash ^= Target.GetHashCode();
          if (options_ != null) hash ^= Options.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasTarget) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Target);
          }
          if (options_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Options);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AuxFieldOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasTarget) {
            Target = other.Target;
          }
          if (other.options_ != null) {
            if (options_ == null) {
              Options = new global::Scalapb.FieldOptions();
            }
            Options.MergeFrom(other.Options);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.FieldOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.FieldOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// AuxEnumOptions enables you to set enum-level options through package-scoped options.
      /// This is useful when you can't add a dependency on scalapb.proto from the proto file that
      /// defines the enum.
      /// </summary>
      public sealed partial class AuxEnumOptions : pb::IMessage<AuxEnumOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AuxEnumOptions> _parser = new pb::MessageParser<AuxEnumOptions>(() => new AuxEnumOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AuxEnumOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Scalapb.ScalaPbOptions.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxEnumOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxEnumOptions(AuxEnumOptions other) : this() {
          target_ = other.target_;
          options_ = other.options_ != null ? other.options_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxEnumOptions Clone() {
          return new AuxEnumOptions(this);
        }

        /// <summary>Field number for the "target" field.</summary>
        public const int TargetFieldNumber = 1;
        private readonly static string TargetDefaultValue = "";

        private string target_;
        /// <summary>
        /// The fully-qualified name of the enum in the proto name space.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Target {
          get { return target_ ?? TargetDefaultValue; }
          set {
            target_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "target" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTarget {
          get { return target_ != null; }
        }
        /// <summary>Clears the value of the "target" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTarget() {
          target_ = null;
        }

        /// <summary>Field number for the "options" field.</summary>
        public const int OptionsFieldNumber = 2;
        private global::Scalapb.EnumOptions options_;
        /// <summary>
        /// Options to apply to the enum. If there are any options defined on the target enum
        /// they take precedence over the options.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Scalapb.EnumOptions Options {
          get { return options_; }
          set {
            options_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AuxEnumOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AuxEnumOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Target != other.Target) return false;
          if (!object.Equals(Options, other.Options)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasTarget) hash ^= Target.GetHashCode();
          if (options_ != null) hash ^= Options.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasTarget) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Target);
          }
          if (options_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Options);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AuxEnumOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasTarget) {
            Target = other.Target;
          }
          if (other.options_ != null) {
            if (options_ == null) {
              Options = new global::Scalapb.EnumOptions();
            }
            Options.MergeFrom(other.Options);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.EnumOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.EnumOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// AuxEnumValueOptions enables you to set enum value level options through package-scoped
      /// options.  This is useful when you can't add a dependency on scalapb.proto from the proto
      /// file that defines the enum.
      /// </summary>
      public sealed partial class AuxEnumValueOptions : pb::IMessage<AuxEnumValueOptions>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<AuxEnumValueOptions> _parser = new pb::MessageParser<AuxEnumValueOptions>(() => new AuxEnumValueOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AuxEnumValueOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Scalapb.ScalaPbOptions.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxEnumValueOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxEnumValueOptions(AuxEnumValueOptions other) : this() {
          target_ = other.target_;
          options_ = other.options_ != null ? other.options_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AuxEnumValueOptions Clone() {
          return new AuxEnumValueOptions(this);
        }

        /// <summary>Field number for the "target" field.</summary>
        public const int TargetFieldNumber = 1;
        private readonly static string TargetDefaultValue = "";

        private string target_;
        /// <summary>
        /// The fully-qualified name of the enum value in the proto name space.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Target {
          get { return target_ ?? TargetDefaultValue; }
          set {
            target_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "target" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTarget {
          get { return target_ != null; }
        }
        /// <summary>Clears the value of the "target" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTarget() {
          target_ = null;
        }

        /// <summary>Field number for the "options" field.</summary>
        public const int OptionsFieldNumber = 2;
        private global::Scalapb.EnumValueOptions options_;
        /// <summary>
        /// Options to apply to the enum value. If there are any options defined on
        /// the target enum value they take precedence over the options.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Scalapb.EnumValueOptions Options {
          get { return options_; }
          set {
            options_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AuxEnumValueOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AuxEnumValueOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Target != other.Target) return false;
          if (!object.Equals(Options, other.Options)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasTarget) hash ^= Target.GetHashCode();
          if (options_ != null) hash ^= Options.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasTarget) {
            output.WriteRawTag(10);
            output.WriteString(Target);
          }
          if (options_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Options);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasTarget) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Target);
          }
          if (options_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Options);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AuxEnumValueOptions other) {
          if (other == null) {
            return;
          }
          if (other.HasTarget) {
            Target = other.Target;
          }
          if (other.options_ != null) {
            if (options_ == null) {
              Options = new global::Scalapb.EnumValueOptions();
            }
            Options.MergeFrom(other.Options);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.EnumValueOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Target = input.ReadString();
                break;
              }
              case 18: {
                if (options_ == null) {
                  Options = new global::Scalapb.EnumValueOptions();
                }
                input.ReadMessage(Options);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  public sealed partial class MessageOptions : pb::IExtendableMessage<MessageOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MessageOptions> _parser = new pb::MessageParser<MessageOptions>(() => new MessageOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<MessageOptions> _extensions;
    private pb::ExtensionSet<MessageOptions> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MessageOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scalapb.ScalapbReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MessageOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MessageOptions(MessageOptions other) : this() {
      _hasBits0 = other._hasBits0;
      extends_ = other.extends_.Clone();
      companionExtends_ = other.companionExtends_.Clone();
      annotations_ = other.annotations_.Clone();
      type_ = other.type_;
      companionAnnotations_ = other.companionAnnotations_.Clone();
      sealedOneofExtends_ = other.sealedOneofExtends_.Clone();
      noBox_ = other.noBox_;
      unknownFieldsAnnotations_ = other.unknownFieldsAnnotations_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MessageOptions Clone() {
      return new MessageOptions(this);
    }

    /// <summary>Field number for the "extends" field.</summary>
    public const int ExtendsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_extends_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> extends_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Additional classes and traits to mix in to the case class.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Extends {
      get { return extends_; }
    }

    /// <summary>Field number for the "companion_extends" field.</summary>
    public const int CompanionExtendsFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_companionExtends_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> companionExtends_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Additional classes and traits to mix in to the companion object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CompanionExtends {
      get { return companionExtends_; }
    }

    /// <summary>Field number for the "annotations" field.</summary>
    public const int AnnotationsFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_annotations_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> annotations_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Custom annotations to add to the generated case class.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Annotations {
      get { return annotations_; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// All instances of this message will be converted to this type. An implicit TypeMapper
    /// must be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "companion_annotations" field.</summary>
    public const int CompanionAnnotationsFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_companionAnnotations_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> companionAnnotations_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Custom annotations to add to the companion object of the generated class.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CompanionAnnotations {
      get { return companionAnnotations_; }
    }

    /// <summary>Field number for the "sealed_oneof_extends" field.</summary>
    public const int SealedOneofExtendsFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_sealedOneofExtends_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> sealedOneofExtends_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Additional classes and traits to mix in to generated sealed_oneof base trait.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> SealedOneofExtends {
      get { return sealedOneofExtends_; }
    }

    /// <summary>Field number for the "no_box" field.</summary>
    public const int NoBoxFieldNumber = 7;
    private readonly static bool NoBoxDefaultValue = false;

    private bool noBox_;
    /// <summary>
    /// If true, when this message is used as an optional field, do not wrap it in an `Option`.
    /// This is equivalent of setting `(field).no_box` to true on each field with the message type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NoBox {
      get { if ((_hasBits0 & 1) != 0) { return noBox_; } else { return NoBoxDefaultValue; } }
      set {
        _hasBits0 |= 1;
        noBox_ = value;
      }
    }
    /// <summary>Gets whether the "no_box" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNoBox {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "no_box" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNoBox() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "unknown_fields_annotations" field.</summary>
    public const int UnknownFieldsAnnotationsFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_unknownFieldsAnnotations_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> unknownFieldsAnnotations_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Custom annotations to add to the generated `unknownFields` case class field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> UnknownFieldsAnnotations {
      get { return unknownFieldsAnnotations_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MessageOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MessageOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!extends_.Equals(other.extends_)) return false;
      if(!companionExtends_.Equals(other.companionExtends_)) return false;
      if(!annotations_.Equals(other.annotations_)) return false;
      if (Type != other.Type) return false;
      if(!companionAnnotations_.Equals(other.companionAnnotations_)) return false;
      if(!sealedOneofExtends_.Equals(other.sealedOneofExtends_)) return false;
      if (NoBox != other.NoBox) return false;
      if(!unknownFieldsAnnotations_.Equals(other.unknownFieldsAnnotations_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= extends_.GetHashCode();
      hash ^= companionExtends_.GetHashCode();
      hash ^= annotations_.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      hash ^= companionAnnotations_.GetHashCode();
      hash ^= sealedOneofExtends_.GetHashCode();
      if (HasNoBox) hash ^= NoBox.GetHashCode();
      hash ^= unknownFieldsAnnotations_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      extends_.WriteTo(output, _repeated_extends_codec);
      companionExtends_.WriteTo(output, _repeated_companionExtends_codec);
      annotations_.WriteTo(output, _repeated_annotations_codec);
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      companionAnnotations_.WriteTo(output, _repeated_companionAnnotations_codec);
      sealedOneofExtends_.WriteTo(output, _repeated_sealedOneofExtends_codec);
      if (HasNoBox) {
        output.WriteRawTag(56);
        output.WriteBool(NoBox);
      }
      unknownFieldsAnnotations_.WriteTo(output, _repeated_unknownFieldsAnnotations_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      extends_.WriteTo(ref output, _repeated_extends_codec);
      companionExtends_.WriteTo(ref output, _repeated_companionExtends_codec);
      annotations_.WriteTo(ref output, _repeated_annotations_codec);
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      companionAnnotations_.WriteTo(ref output, _repeated_companionAnnotations_codec);
      sealedOneofExtends_.WriteTo(ref output, _repeated_sealedOneofExtends_codec);
      if (HasNoBox) {
        output.WriteRawTag(56);
        output.WriteBool(NoBox);
      }
      unknownFieldsAnnotations_.WriteTo(ref output, _repeated_unknownFieldsAnnotations_codec);
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += extends_.CalculateSize(_repeated_extends_codec);
      size += companionExtends_.CalculateSize(_repeated_companionExtends_codec);
      size += annotations_.CalculateSize(_repeated_annotations_codec);
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      size += companionAnnotations_.CalculateSize(_repeated_companionAnnotations_codec);
      size += sealedOneofExtends_.CalculateSize(_repeated_sealedOneofExtends_codec);
      if (HasNoBox) {
        size += 1 + 1;
      }
      size += unknownFieldsAnnotations_.CalculateSize(_repeated_unknownFieldsAnnotations_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MessageOptions other) {
      if (other == null) {
        return;
      }
      extends_.Add(other.extends_);
      companionExtends_.Add(other.companionExtends_);
      annotations_.Add(other.annotations_);
      if (other.HasType) {
        Type = other.Type;
      }
      companionAnnotations_.Add(other.companionAnnotations_);
      sealedOneofExtends_.Add(other.sealedOneofExtends_);
      if (other.HasNoBox) {
        NoBox = other.NoBox;
      }
      unknownFieldsAnnotations_.Add(other.unknownFieldsAnnotations_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(input, _repeated_extends_codec);
            break;
          }
          case 18: {
            companionExtends_.AddEntriesFrom(input, _repeated_companionExtends_codec);
            break;
          }
          case 26: {
            annotations_.AddEntriesFrom(input, _repeated_annotations_codec);
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            companionAnnotations_.AddEntriesFrom(input, _repeated_companionAnnotations_codec);
            break;
          }
          case 50: {
            sealedOneofExtends_.AddEntriesFrom(input, _repeated_sealedOneofExtends_codec);
            break;
          }
          case 56: {
            NoBox = input.ReadBool();
            break;
          }
          case 66: {
            unknownFieldsAnnotations_.AddEntriesFrom(input, _repeated_unknownFieldsAnnotations_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(ref input, _repeated_extends_codec);
            break;
          }
          case 18: {
            companionExtends_.AddEntriesFrom(ref input, _repeated_companionExtends_codec);
            break;
          }
          case 26: {
            annotations_.AddEntriesFrom(ref input, _repeated_annotations_codec);
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            companionAnnotations_.AddEntriesFrom(ref input, _repeated_companionAnnotations_codec);
            break;
          }
          case 50: {
            sealedOneofExtends_.AddEntriesFrom(ref input, _repeated_sealedOneofExtends_codec);
            break;
          }
          case 56: {
            NoBox = input.ReadBool();
            break;
          }
          case 66: {
            unknownFieldsAnnotations_.AddEntriesFrom(ref input, _repeated_unknownFieldsAnnotations_codec);
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<MessageOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<MessageOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<MessageOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<MessageOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<MessageOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<MessageOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<MessageOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  public sealed partial class FieldOptions : pb::IExtendableMessage<FieldOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FieldOptions> _parser = new pb::MessageParser<FieldOptions>(() => new FieldOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<FieldOptions> _extensions;
    private pb::ExtensionSet<FieldOptions> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FieldOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scalapb.ScalapbReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldOptions(FieldOptions other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      scalaName_ = other.scalaName_;
      collectionType_ = other.collectionType_;
      keyType_ = other.keyType_;
      valueType_ = other.valueType_;
      annotations_ = other.annotations_.Clone();
      mapType_ = other.mapType_;
      noBox_ = other.noBox_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldOptions Clone() {
      return new FieldOptions(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "scala_name" field.</summary>
    public const int ScalaNameFieldNumber = 2;
    private readonly static string ScalaNameDefaultValue = "";

    private string scalaName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ScalaName {
      get { return scalaName_ ?? ScalaNameDefaultValue; }
      set {
        scalaName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "scala_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScalaName {
      get { return scalaName_ != null; }
    }
    /// <summary>Clears the value of the "scala_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScalaName() {
      scalaName_ = null;
    }

    /// <summary>Field number for the "collection_type" field.</summary>
    public const int CollectionTypeFieldNumber = 3;
    private readonly static string CollectionTypeDefaultValue = "";

    private string collectionType_;
    /// <summary>
    /// Can be specified only if this field is repeated. If unspecified,
    /// it falls back to the file option named `collection_type`, which defaults
    /// to `scala.collection.Seq`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectionType {
      get { return collectionType_ ?? CollectionTypeDefaultValue; }
      set {
        collectionType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "collection_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCollectionType {
      get { return collectionType_ != null; }
    }
    /// <summary>Clears the value of the "collection_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCollectionType() {
      collectionType_ = null;
    }

    /// <summary>Field number for the "key_type" field.</summary>
    public const int KeyTypeFieldNumber = 4;
    private readonly static string KeyTypeDefaultValue = "";

    private string keyType_;
    /// <summary>
    /// If the field is a map, you can specify custom Scala types for the key
    /// or value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string KeyType {
      get { return keyType_ ?? KeyTypeDefaultValue; }
      set {
        keyType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasKeyType {
      get { return keyType_ != null; }
    }
    /// <summary>Clears the value of the "key_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearKeyType() {
      keyType_ = null;
    }

    /// <summary>Field number for the "value_type" field.</summary>
    public const int ValueTypeFieldNumber = 5;
    private readonly static string ValueTypeDefaultValue = "";

    private string valueType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ValueType {
      get { return valueType_ ?? ValueTypeDefaultValue; }
      set {
        valueType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasValueType {
      get { return valueType_ != null; }
    }
    /// <summary>Clears the value of the "value_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValueType() {
      valueType_ = null;
    }

    /// <summary>Field number for the "annotations" field.</summary>
    public const int AnnotationsFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_annotations_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> annotations_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Custom annotations to add to the field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Annotations {
      get { return annotations_; }
    }

    /// <summary>Field number for the "map_type" field.</summary>
    public const int MapTypeFieldNumber = 7;
    private readonly static string MapTypeDefaultValue = "";

    private string mapType_;
    /// <summary>
    /// Can be specified only if this field is a map. If unspecified,
    /// it falls back to the file option named `map_type` which defaults to
    /// `scala.collection.immutable.Map`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MapType {
      get { return mapType_ ?? MapTypeDefaultValue; }
      set {
        mapType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "map_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMapType {
      get { return mapType_ != null; }
    }
    /// <summary>Clears the value of the "map_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMapType() {
      mapType_ = null;
    }

    /// <summary>Field number for the "no_box" field.</summary>
    public const int NoBoxFieldNumber = 30;
    private readonly static bool NoBoxDefaultValue = false;

    private bool noBox_;
    /// <summary>
    /// Do not box this value in Option[T]. If set, this overrides MessageOptions.no_box
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NoBox {
      get { if ((_hasBits0 & 1) != 0) { return noBox_; } else { return NoBoxDefaultValue; } }
      set {
        _hasBits0 |= 1;
        noBox_ = value;
      }
    }
    /// <summary>Gets whether the "no_box" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNoBox {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "no_box" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNoBox() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FieldOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FieldOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (ScalaName != other.ScalaName) return false;
      if (CollectionType != other.CollectionType) return false;
      if (KeyType != other.KeyType) return false;
      if (ValueType != other.ValueType) return false;
      if(!annotations_.Equals(other.annotations_)) return false;
      if (MapType != other.MapType) return false;
      if (NoBox != other.NoBox) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasScalaName) hash ^= ScalaName.GetHashCode();
      if (HasCollectionType) hash ^= CollectionType.GetHashCode();
      if (HasKeyType) hash ^= KeyType.GetHashCode();
      if (HasValueType) hash ^= ValueType.GetHashCode();
      hash ^= annotations_.GetHashCode();
      if (HasMapType) hash ^= MapType.GetHashCode();
      if (HasNoBox) hash ^= NoBox.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasScalaName) {
        output.WriteRawTag(18);
        output.WriteString(ScalaName);
      }
      if (HasCollectionType) {
        output.WriteRawTag(26);
        output.WriteString(CollectionType);
      }
      if (HasKeyType) {
        output.WriteRawTag(34);
        output.WriteString(KeyType);
      }
      if (HasValueType) {
        output.WriteRawTag(42);
        output.WriteString(ValueType);
      }
      annotations_.WriteTo(output, _repeated_annotations_codec);
      if (HasMapType) {
        output.WriteRawTag(58);
        output.WriteString(MapType);
      }
      if (HasNoBox) {
        output.WriteRawTag(240, 1);
        output.WriteBool(NoBox);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasScalaName) {
        output.WriteRawTag(18);
        output.WriteString(ScalaName);
      }
      if (HasCollectionType) {
        output.WriteRawTag(26);
        output.WriteString(CollectionType);
      }
      if (HasKeyType) {
        output.WriteRawTag(34);
        output.WriteString(KeyType);
      }
      if (HasValueType) {
        output.WriteRawTag(42);
        output.WriteString(ValueType);
      }
      annotations_.WriteTo(ref output, _repeated_annotations_codec);
      if (HasMapType) {
        output.WriteRawTag(58);
        output.WriteString(MapType);
      }
      if (HasNoBox) {
        output.WriteRawTag(240, 1);
        output.WriteBool(NoBox);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasScalaName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ScalaName);
      }
      if (HasCollectionType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectionType);
      }
      if (HasKeyType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KeyType);
      }
      if (HasValueType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ValueType);
      }
      size += annotations_.CalculateSize(_repeated_annotations_codec);
      if (HasMapType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MapType);
      }
      if (HasNoBox) {
        size += 2 + 1;
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FieldOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasScalaName) {
        ScalaName = other.ScalaName;
      }
      if (other.HasCollectionType) {
        CollectionType = other.CollectionType;
      }
      if (other.HasKeyType) {
        KeyType = other.KeyType;
      }
      if (other.HasValueType) {
        ValueType = other.ValueType;
      }
      annotations_.Add(other.annotations_);
      if (other.HasMapType) {
        MapType = other.MapType;
      }
      if (other.HasNoBox) {
        NoBox = other.NoBox;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            ScalaName = input.ReadString();
            break;
          }
          case 26: {
            CollectionType = input.ReadString();
            break;
          }
          case 34: {
            KeyType = input.ReadString();
            break;
          }
          case 42: {
            ValueType = input.ReadString();
            break;
          }
          case 50: {
            annotations_.AddEntriesFrom(input, _repeated_annotations_codec);
            break;
          }
          case 58: {
            MapType = input.ReadString();
            break;
          }
          case 240: {
            NoBox = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            ScalaName = input.ReadString();
            break;
          }
          case 26: {
            CollectionType = input.ReadString();
            break;
          }
          case 34: {
            KeyType = input.ReadString();
            break;
          }
          case 42: {
            ValueType = input.ReadString();
            break;
          }
          case 50: {
            annotations_.AddEntriesFrom(ref input, _repeated_annotations_codec);
            break;
          }
          case 58: {
            MapType = input.ReadString();
            break;
          }
          case 240: {
            NoBox = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<FieldOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<FieldOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<FieldOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<FieldOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<FieldOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<FieldOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<FieldOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  public sealed partial class EnumOptions : pb::IExtendableMessage<EnumOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnumOptions> _parser = new pb::MessageParser<EnumOptions>(() => new EnumOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<EnumOptions> _extensions;
    private pb::ExtensionSet<EnumOptions> _Extensions { get { return _extensions; } }
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EnumOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scalapb.ScalapbReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnumOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnumOptions(EnumOptions other) : this() {
      extends_ = other.extends_.Clone();
      companionExtends_ = other.companionExtends_.Clone();
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnumOptions Clone() {
      return new EnumOptions(this);
    }

    /// <summary>Field number for the "extends" field.</summary>
    public const int ExtendsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_extends_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> extends_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Additional classes and traits to mix in to the base trait
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Extends {
      get { return extends_; }
    }

    /// <summary>Field number for the "companion_extends" field.</summary>
    public const int CompanionExtendsFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_companionExtends_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> companionExtends_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Additional classes and traits to mix in to the companion object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CompanionExtends {
      get { return companionExtends_; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// All instances of this enum will be converted to this type. An implicit TypeMapper
    /// must be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EnumOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EnumOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!extends_.Equals(other.extends_)) return false;
      if(!companionExtends_.Equals(other.companionExtends_)) return false;
      if (Type != other.Type) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= extends_.GetHashCode();
      hash ^= companionExtends_.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      extends_.WriteTo(output, _repeated_extends_codec);
      companionExtends_.WriteTo(output, _repeated_companionExtends_codec);
      if (HasType) {
        output.WriteRawTag(26);
        output.WriteString(Type);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      extends_.WriteTo(ref output, _repeated_extends_codec);
      companionExtends_.WriteTo(ref output, _repeated_companionExtends_codec);
      if (HasType) {
        output.WriteRawTag(26);
        output.WriteString(Type);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += extends_.CalculateSize(_repeated_extends_codec);
      size += companionExtends_.CalculateSize(_repeated_companionExtends_codec);
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EnumOptions other) {
      if (other == null) {
        return;
      }
      extends_.Add(other.extends_);
      companionExtends_.Add(other.companionExtends_);
      if (other.HasType) {
        Type = other.Type;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(input, _repeated_extends_codec);
            break;
          }
          case 18: {
            companionExtends_.AddEntriesFrom(input, _repeated_companionExtends_codec);
            break;
          }
          case 26: {
            Type = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(ref input, _repeated_extends_codec);
            break;
          }
          case 18: {
            companionExtends_.AddEntriesFrom(ref input, _repeated_companionExtends_codec);
            break;
          }
          case 26: {
            Type = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<EnumOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<EnumOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<EnumOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<EnumOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<EnumOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<EnumOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<EnumOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  public sealed partial class EnumValueOptions : pb::IExtendableMessage<EnumValueOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnumValueOptions> _parser = new pb::MessageParser<EnumValueOptions>(() => new EnumValueOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<EnumValueOptions> _extensions;
    private pb::ExtensionSet<EnumValueOptions> _Extensions { get { return _extensions; } }
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EnumValueOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scalapb.ScalapbReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnumValueOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnumValueOptions(EnumValueOptions other) : this() {
      extends_ = other.extends_.Clone();
      scalaName_ = other.scalaName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnumValueOptions Clone() {
      return new EnumValueOptions(this);
    }

    /// <summary>Field number for the "extends" field.</summary>
    public const int ExtendsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_extends_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> extends_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Additional classes and traits to mix in to an individual enum value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Extends {
      get { return extends_; }
    }

    /// <summary>Field number for the "scala_name" field.</summary>
    public const int ScalaNameFieldNumber = 2;
    private readonly static string ScalaNameDefaultValue = "";

    private string scalaName_;
    /// <summary>
    /// Name in Scala to use for this enum value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ScalaName {
      get { return scalaName_ ?? ScalaNameDefaultValue; }
      set {
        scalaName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "scala_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScalaName {
      get { return scalaName_ != null; }
    }
    /// <summary>Clears the value of the "scala_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScalaName() {
      scalaName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EnumValueOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EnumValueOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!extends_.Equals(other.extends_)) return false;
      if (ScalaName != other.ScalaName) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= extends_.GetHashCode();
      if (HasScalaName) hash ^= ScalaName.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      extends_.WriteTo(output, _repeated_extends_codec);
      if (HasScalaName) {
        output.WriteRawTag(18);
        output.WriteString(ScalaName);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      extends_.WriteTo(ref output, _repeated_extends_codec);
      if (HasScalaName) {
        output.WriteRawTag(18);
        output.WriteString(ScalaName);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += extends_.CalculateSize(_repeated_extends_codec);
      if (HasScalaName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ScalaName);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EnumValueOptions other) {
      if (other == null) {
        return;
      }
      extends_.Add(other.extends_);
      if (other.HasScalaName) {
        ScalaName = other.ScalaName;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(input, _repeated_extends_codec);
            break;
          }
          case 18: {
            ScalaName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(ref input, _repeated_extends_codec);
            break;
          }
          case 18: {
            ScalaName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<EnumValueOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<EnumValueOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<EnumValueOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<EnumValueOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<EnumValueOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<EnumValueOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<EnumValueOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  public sealed partial class OneofOptions : pb::IExtendableMessage<OneofOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<OneofOptions> _parser = new pb::MessageParser<OneofOptions>(() => new OneofOptions());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<OneofOptions> _extensions;
    private pb::ExtensionSet<OneofOptions> _Extensions { get { return _extensions; } }
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OneofOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Scalapb.ScalapbReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OneofOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OneofOptions(OneofOptions other) : this() {
      extends_ = other.extends_.Clone();
      scalaName_ = other.scalaName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OneofOptions Clone() {
      return new OneofOptions(this);
    }

    /// <summary>Field number for the "extends" field.</summary>
    public const int ExtendsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_extends_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> extends_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Additional traits to mix in to a oneof.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Extends {
      get { return extends_; }
    }

    /// <summary>Field number for the "scala_name" field.</summary>
    public const int ScalaNameFieldNumber = 2;
    private readonly static string ScalaNameDefaultValue = "";

    private string scalaName_;
    /// <summary>
    /// Name in Scala to use for this oneof field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ScalaName {
      get { return scalaName_ ?? ScalaNameDefaultValue; }
      set {
        scalaName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "scala_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScalaName {
      get { return scalaName_ != null; }
    }
    /// <summary>Clears the value of the "scala_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScalaName() {
      scalaName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OneofOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OneofOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!extends_.Equals(other.extends_)) return false;
      if (ScalaName != other.ScalaName) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= extends_.GetHashCode();
      if (HasScalaName) hash ^= ScalaName.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      extends_.WriteTo(output, _repeated_extends_codec);
      if (HasScalaName) {
        output.WriteRawTag(18);
        output.WriteString(ScalaName);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      extends_.WriteTo(ref output, _repeated_extends_codec);
      if (HasScalaName) {
        output.WriteRawTag(18);
        output.WriteString(ScalaName);
      }
      if (_extensions != null) {
        _extensions.WriteTo(ref output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += extends_.CalculateSize(_repeated_extends_codec);
      if (HasScalaName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ScalaName);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OneofOptions other) {
      if (other == null) {
        return;
      }
      extends_.Add(other.extends_);
      if (other.HasScalaName) {
        ScalaName = other.ScalaName;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(input, _repeated_extends_codec);
            break;
          }
          case 18: {
            ScalaName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, ref input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            }
            break;
          case 10: {
            extends_.AddEntriesFrom(ref input, _repeated_extends_codec);
            break;
          }
          case 18: {
            ScalaName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    public TValue GetExtension<TValue>(pb::Extension<OneofOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<OneofOptions, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<OneofOptions, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<OneofOptions, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<OneofOptions, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<OneofOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<OneofOptions, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  #endregion

}

#endregion Designer generated code
